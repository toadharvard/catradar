## Требования 
Условие задачи доступно по [ссылке](https://docs.google.com/document/d/1XVtSK7dWyxdnMc5_6oWdgPVQMg05BTsL3GECMffpDtE/edit?tab=t.0). Необходимо разработать приложение для моделирования и визуализации в реальном времени поведения большого количества котов на прямоугольной карте.
На основе условия были сформированы следующие требования:

 - Приложение должно быть кроссплатформенным и корректно работать на следующих системах: Windows, Linux, macOS
 - Движение котов
   - Коты должны перемещаться по полю, не имея возможности выйти за его границы
   - Приложение должно само генерировать данные о позициях котов на поле на основе паттернов движения, а не получать их из внешнего источника
   - Пользователь должен иметь возможность выбирать паттерн движения котов. Всего необходимо поддерживать 3 паттерна:
     - Свободное (все коты движутся по прямой и не сталкиваются)
     - Карусельное (коты движутся по кругу, не сталкиваются)
     - Со сталкиванием (коты движутся по прямой, но меняют направление движения при столкновении с другими котами)
   - Пользователь должен иметь возможность регулировать скорость перемещения котов
   - Пользователь может "разогнать котов": при нажатии по полю, коты, находящиеся рядом с курсором, должны резко покинуть эту зону
   - Пересчет позиций котов должно происходить за время, не превышающее \tau 
 - Симуляция
   - Необходима возможность перезапуска симуляции с новыми параметрами (размер поля, количество котов и т д)
   - Пользователь должен иметь возможность выбрать кота, смена состояний которого будет логироваться 
   - Пользователь может выбирать одну из трех функций подсчета расстояний между котами:
     - Евклидово
     - Манхэттенское
     - Чебышёва
   - В любой момент времени состояние 95% котов должно быть определено корректно
   - Пересчет состояний котов должен происходить за время, не превышающее \tau 
 - Графический интерфейс
   - Показывает все необходимые настройки симуляции, панель с логами и поле с котами
   - Пользователь должен иметь возможность увидеть каждого кота
   - Выбранный пользователем логируемый кот должен отличаться внешним видом от всех остальных
   - Внешний вид котов с разными состояниями должен отличаться
   - Внешний вид котов с одинаковыми состояниями должен быть одинаков (исключение - логируемый кот)

## Инструменты
### Taichi
Основным фреймворком для нашего приложения был выбран [Taichi](https://www.taichi-lang.org/) (встроенный в python язык программирования для высокопроизводительных численных вычислений). Основными причинами его выбора послужили простота реализаций на нём высокопроизводительных систем и его мультиплатформенность.


### Альтернативы

У каждого участника в нашей команде разные операционные системы, поэтому при выборе фреймворка мы обращали внимание на поддержку MacOS и Linux.
При этом, если разрабатываемый инструмент станет кроссплатформенным, это, несомненно, будет плюсом для пользователей.
В процессе выбора инструментов для разработки мы рассматривали следующие фреймворки, но в итоге отказались от их использования по ряду причин:

-   **OpenGL:**
    *  **Ограниченная поддержка на macOS:** В 2018 году компания Apple объявила OpenGL устаревшим на своих продуктах, рекомендуя вместо него использовать Metal. Это может привести к трудностям в использовании OpenGL и проблемам с производительностью на платформе macOS.
    *   **Низкоуровневый API:** OpenGL предоставляет низкоуровневый API, требующий большого количества ручной работы для отрисовки даже простых сцен, что значительно увеличивает сложность и время разработки.

-   **Vulkan:**
    *   **Более трудоемкое программирование:** Vulkan требует значительных усилий для управления ресурсами, состояниями и синхронизацией, что усложняет разработку. Поэтому вместо Vulkan нередко используют библиотеки написаные поверх него (к примеру Taichi).

-   **Metal (Apple):**
    *   **Ограничение платформы:** Metal является проприетарным API от Apple и работает **только на macOS и iOS**. Это делает его непригодным для нашего проекта, который должен быть кроссплатформенным.

Таким образом, был выбран именно Taichi, плюсы которого описаны в разделе выше.

## Алгоритм

В качестве алгоритма для определения взаимодействующих котов была взята одна из реализаций поиска соседей на основе сеточного разбиения (grid-based neighborhood search). Конкретная реализация алгоритма была взята отсюда https://docs.taichi-lang.org/blog/acclerate-collision-detection-with-taichi

### Альтернатива
При обсуждении деталей проекта также рассматривался алгоритм Форчуна, который обсуждался в рамках лекций по компьютерной графике. Однако от его использования было принято решение отказаться. Основным преимуществом сеточного разбиения перед алгоритмом Форчуна стала относительная простота реализации первого.
После реализации сеточного разбиения и покрытия его тестами мы убедились, что он дает требуемые результаты по точности и производительности.

## Архитектура проекта

Работа с Taichi накладывает некоторые ограничения на разработку. Из-за чего в рамках проекта не встречаются собственные классы и по большей части они заменены файлами. Для корректной работы большинства файлов прежде всего нужно проинициализировать их данные с помощью функции `setup_...()`

![catradar-arch](https://github.com/user-attachments/assets/477128a4-c033-425c-a51a-bc784d69b795)

*Архитектура проекта (не UML)*

### `__main__.py`

Файл, содержащий главный цикл, который отвечает за обновление всех необходимых компонентов.
А так же файл отвечающий за пользовательские настройки.

### `canvas.py`
Файл отвечающий за отображение "холста" с котами.
Публичные функции:
- setup_data_for_scene: инициализация данных
- draw_borders: отрисовка границ области (вынесено в отдельную функцию для возможности отключить для повышения производительности)
- draw_circles: отрисовка котов/точек


### `grid_manager.py`
Файл отвечающий за обновление состояний у котов и сбор логов.

Публичные функции:
- setup_grid_data: инициализация данных
- compute_states: пересчёт состояний с использованием сетки
- update_logs: добавление в лог нового сообщения, если состояние логируемого кота изменилось


### `positions_updater.py`
Файл отвечающий за обновление позиций у котов.

Публичные функции:
- setup_positions_data: инициализация данных
- initialize_positions: инициализация(/сброс) позиций
- update_positions: обновление позиции котов на основе выбранного паттерна движения



### Вспомогательные файлы
#### `common.py`
Содержит общие константы.
- "enum" возможных состояний котов
	- и его отображение в строки
- "enum" метрик расстояния
- "enum" паттернов перемещения котов
- "enum" возможных режимов работ программы
	- обычное
	- запуск для тестов

#### `utils.py`
Файл с общими вспомогательными вещами. В данный момент содержит только функцию `trace()` для отслеживания времени выполнения отдельных частей кода.
