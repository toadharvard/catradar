## Инструменты
### Taichi
Основным фреймворком для нашего приложения был выбран [Taichi](https://www.taichi-lang.org/) (встроенный в python язык программирования для высокопроизводительных численных вычислений). Основными причинами его выбора послужили простота реализаций на нём высокопроизводительных систем и его мультиплатформенность.


### Альтернативы

У каждого участника в нашей команде разные операционные системы, поэтому при выборе фреймворка мы обращали внимание на поддержку MacOS и Linux.
При этом, если разрабатываемый инструмент станет кроссплатформенным, это, несомненно, будет плюсом для пользователей.
В процессе выбора инструментов для разработки мы рассматривали следующие фреймворки, но в итоге отказались от их использования по ряду причин:

-   **OpenGL:**
    *  **Ограниченная поддержка на macOS:** В 2018 году компания Apple объявила OpenGL устаревшим на своих продуктах, рекомендуя вместо него использовать Metal. Это может привести к трудностям в использовании OpenGL и проблемам с производительностью на платформе macOS.
    *   **Низкоуровневый API:** OpenGL предоставляет низкоуровневый API, требующий большого количества ручной работы для отрисовки даже простых сцен, что значительно увеличивает сложность и время разработки.

-   **Vulkan:**
    *   **Более трудоемкое программирование:** Vulkan требует значительных усилий для управления ресурсами, состояниями и синхронизацией, что усложняет разработку. Поэтому вместо Vulkan нередко используют библиотеки написаные поверх него (к примеру Taichi).

-   **Metal (Apple):**
    *   **Ограничение платформы:** Metal является проприетарным API от Apple и работает **только на macOS и iOS**. Это делает его непригодным для нашего проекта, который должен быть кроссплатформенным.

Таким образом, был выбран именно Taichi, плюсы которого описаны в разделе выше.

## Алгоритм

В качестве алгоритма для определения взаимодействующих котов была взята одна из реализаций поиска соседей на основе сеточного разбиения (grid-based neighborhood search). Конкретная реализация алгоритма была взята отсюда https://docs.taichi-lang.org/blog/acclerate-collision-detection-with-taichi

### Альтернатива
При обсуждении деталей проекта также рассматривался алгоритм Форчуна, который обсуждался в рамках лекций по компьютерной графике. Однако от его использования было принято решение отказаться. Основным преимуществом сеточного разбиения перед алгоритмом Форчуна стала относительная простота реализации первого.
После реализации сеточного разбиения и покрытия его тестами мы убедились, что он дает требуемые результаты по точности и производительности.

## Архитектура проекта

Работа с Taichi накладывает некоторые ограничения на разработку. Из-за чего в рамках проекта не встречаются собственные классы и по большей части они заменены файлами. Для корректной работы большинства файлов прежде всего нужно проинициализировать их данные с помощью функции `setup_...()`

![catradar-arch](https://github.com/user-attachments/assets/477128a4-c033-425c-a51a-bc784d69b795)

*Архитектура проекта (не UML)*

### `__main__.py`

Файл, содержащий главный цикл, который отвечает за обновление всех необходимых компонентов.
А так же файл отвечающий за пользовательские настройки.

### `canvas.py`
Файл отвечающий за отображение "холста" с котами.
Публичные функции:
- setup_data_for_scene: инициализация данных
- draw_borders: отрисовка границ области (вынесено в отдельную функцию для возможности отключить для повышения производительности)
- draw_circles: отрисовка котов/точек


### `grid_manager.py`
Файл отвечающий за обновление состояний у котов и сбор логов.

Публичные функции:
- setup_grid_data: инициализация данных
- compute_states: пересчёт состояний с использованием сетки
- update_logs: добавление в лог нового сообщения, если состояние логируемого кота изменилось


### `positions_updater.py`
Файл отвечающий за обновление позиций у котов.

Публичные функции:
- setup_positions_data: инициализация данных
- initialize_positions: инициализация(/сброс) позиций
- update_positions: обновление позиции котов на основе выбранного паттерна движения



### Вспомогательные файлы
#### `common.py`
Содержит общие константы.
- "enum" возможных состояний котов
	- и его отображение в строки
- "enum" метрик расстояния
- "enum" паттернов перемещения котов
- "enum" возможных режимов работ программы
	- обычное
	- запуск для тестов

#### `utils.py`
Файл с общими вспомогательными вещами. В данный момент содержит только функцию `trace()` для отслеживания времени выполнения отдельных частей кода.
